import { Controller, Get, Post, Body, Put, Param, Delete, UseGuards, NotFoundException, Patch, Req, UseInterceptors, UploadedFile, Query } from '@nestjs/common';
import { UserService } from './user.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { JwtAuthGuard } from '@feature/security/guards/jwt-auth.guard';
import { RolesGuard } from '@feature/security/guards/roles.guard';
import { Roles } from '@feature/security/decorators/roles.decorator';
import { UserRole } from './entities/user-role.enum';
import { ApiTags, ApiBearerAuth } from '@nestjs/swagger';
import { User } from './entities/user.entity';
import { JwtGuard } from '@feature/security/guards/jwt.guard';
import { FileInterceptor } from '@nestjs/platform-express';
import { diskStorage } from 'multer';
import * as path from 'path';
import { ContactService } from '../Contact/contact.service';
import { SuggestionsService } from './suggestions.service';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Credential } from '@feature/security/data/entity/credential.entity';

// IMPORTANT :
// Ce contr√¥leur n'a PAS de d√©corateur @Roles ou @UseGuards(RolesGuard) sur la classe.
// La restriction de r√¥le est appliqu√©e uniquement sur la m√©thode findAll pour permettre l'acc√®s √† tous les membres et admins.
// Cela garantit que la messagerie priv√©e fonctionne pour tous les utilisateurs connect√©s.

@ApiTags('Users')
@ApiBearerAuth()
@Controller('users')
export class UserController {
  constructor(
    private readonly userService: UserService,
    private readonly contactService: ContactService,
    private readonly suggestionsService: SuggestionsService,
    @InjectRepository(Credential)
    private readonly credentialRepository: Repository<Credential>
  ) {}

  @Post()
  async create(@Body() createUserDto: CreateUserDto) {
    return await this.userService.create(createUserDto);
  }

  // Route accessible √† tous les utilisateurs connect√©s (MEMBER et ADMIN) pour la messagerie priv√©e.
  // N√©cessaire si le RolesGuard est appliqu√© globalement.
  @Get()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(UserRole.MEMBER, UserRole.ADMIN)
  async findAll(@Req() req) {
    // DEBUG: Affichage du r√¥le utilisateur re√ßu dans findAll (√† activer uniquement en d√©veloppement)
    // console.log('R√¥le utilisateur re√ßu dans findAll:', req.user?.role);
    return await this.userService.findAll();
  }

  // Route d√©di√©e pour la messagerie priv√©e : retourne la liste des membres actifs (sauf soi-m√™me).
  // Accessible √† tous les membres connect√©s, sans restriction de r√¥le.
  @Get('contacts')
  @UseGuards(JwtAuthGuard)
  async getContacts(@Req() req) {
    return this.userService.findContacts(req.user.userId);
  }



  @UseGuards(JwtAuthGuard)
  @Get('profile')
  async getProfile(@Req() req) {
    return this.userService.findOne(req.user.userId);
  }

  @UseGuards(JwtAuthGuard)
  @Put('profile')
  async updateProfile(@Req() req, @Body() updateUserDto: UpdateUserDto) {
    await this.userService.put(req.user.userId, updateUserDto);
    return { code: 'api.common.success', result: true };
  }

  // Route pour rechercher des utilisateurs (pour ajouter des contacts)
  // IMPORTANT : Cette route doit √™tre d√©clar√©e AVANT la route dynamique ':id' !
  @Get('search')
  @UseGuards(JwtAuthGuard)
  async searchUsers(@Req() req, @Query('q') query: string) {
    if (!query || query.trim().length < 2) {
      return [];
    }
    return this.userService.searchUsers(query.trim(), req.user.userId || req.user.id);
  }

  // Route pour les suggestions de contacts
  @Get('suggestions')
  @UseGuards(JwtAuthGuard)
  async getContactSuggestions(@Req() req, @Query('limit') limit?: number) {
    return this.suggestionsService.getContactSuggestions(
      req.user.userId || req.user.id,
      limit ? parseInt(limit.toString()) : 10
    );
  }

  // Nouvelle route pour r√©cup√©rer tous les membres (actifs + inactifs) pour l'admin
  // IMPORTANT : Cette route doit √™tre d√©clar√©e AVANT la route dynamique ':id' !
  // Sinon, /users/all sera interpr√©t√© comme un id et provoquera une erreur de type uuid.
  @Get('all')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(UserRole.ADMIN)
  async findAllUsersAdmin() {
    // Retourne tous les utilisateurs sans filtrer sur isActive
    return await this.userService.findAllAdmin();
  }

  @Get(':id')
  @UseGuards(JwtAuthGuard)
  async findOne(@Param('id') id: string) {
    return await this.userService.findOne(id);
  }

  @Put(':id')
  @UseGuards(JwtAuthGuard)
  async update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    // Update the user information
    await this.userService.put(id, updateUserDto);

    // A confirmation email will be sent to the user after the update
    return { code: 'api.common.success', result: true };
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(UserRole.ADMIN)
  async remove(@Param('id') id: string) {
    // DEBUG: Appel de la route DELETE /users/:id (√† activer uniquement en d√©veloppement)
    // console.log('[UserController] Appel de la route DELETE /users/' + id);
    try {
      await this.userService.remove(id);
      return { code: 'api.common.success', result: true };
    } catch (error) {
      if (error.message === 'Utilisateur d√©j√† d√©sactiv√©') {
        return { code: 'api.user.already_deactivated', message: 'Utilisateur d√©j√† d√©sactiv√©', result: false };
      }
      throw error;
    }
  }

  @Patch(':id/restore')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(UserRole.ADMIN)
  async restore(@Param('id') id: string) {
    try {
      await this.userService.restore(id);
      return { code: 'api.common.success', result: true };
    } catch (error) {
      if (error.message === 'Utilisateur d√©j√† actif') {
        return { code: 'api.user.already_active', message: 'Utilisateur d√©j√† actif', result: false };
      }
      throw error;
    }
  }

  /**
   * Permet √† un utilisateur d'envoyer une demande de contact √† un autre membre.
   * Body attendu : { contactId: string, message?: string }
   */
  @Post('contacts')
  @UseGuards(JwtAuthGuard)
  async addContact(@Req() req, @Body() body) {
    const { contactId, message } = body;
    return this.contactService.sendContactRequest(req.user.userId, contactId);
  }

  @UseGuards(JwtAuthGuard)
  @Post('profile/photo')
  @UseInterceptors(FileInterceptor('photo', {
    storage: diskStorage({
      destination: './public/profiles',
      filename: (req: any, file, cb) => {
        const ext = path.extname(file.originalname);
        const userId = req.user?.userId || req.user?.id || 'unknown';
        const timestamp = Date.now();
        cb(null, `${userId}-${timestamp}${ext}`);
      }
    })
  }))
  async uploadPhoto(@UploadedFile() file: any, @Req() req) {
    try {
      console.log('üì§ Upload photo d√©marr√©...');
      console.log('üì§ Fichier re√ßu:', file ? {
        originalname: file.originalname,
        filename: file.filename,
        mimetype: file.mimetype,
        size: file.size
      } : 'AUCUN FICHIER');
      console.log('üì§ User ID:', req.user?.userId || req.user?.id);

      // V√©rifier que le fichier existe
      if (!file) {
        console.error('‚ùå Aucun fichier re√ßu');
        throw new Error('Aucun fichier re√ßu');
      }

      // V√©rifier que l'utilisateur existe
      if (!req.user?.userId && !req.user?.id) {
        console.error('‚ùå Utilisateur non authentifi√©');
        throw new Error('Utilisateur non authentifi√©');
      }

      const userId = req.user.userId || req.user.id;
      console.log('üì§ User ID final:', userId);

      // R√©cup√©rer l'utilisateur actuel pour supprimer l'ancienne photo
      const currentUser = await this.userService.findOne(userId);
      console.log('üì§ Utilisateur trouv√©:', currentUser ? 'OUI' : 'NON');
      
      // Supprimer l'ancienne photo si elle existe
      if (currentUser?.photo && currentUser.photo !== '/api/files/profiles/default.jpg') {
        const oldPhotoPath = currentUser.photo.replace('/api/files/profiles/', './public/profiles/');
        const fs = require('fs');
        if (fs.existsSync(oldPhotoPath)) {
          fs.unlinkSync(oldPhotoPath);
          console.log(`üóëÔ∏è Ancienne photo supprim√©e: ${oldPhotoPath}`);
        }
      }

      // G√©n√®re l'URL dynamique avec timestamp pour √©viter le cache
      const photoUrl = `/api/files/profiles/${file.filename}?t=${Date.now()}`;
      console.log('üì§ URL photo g√©n√©r√©e:', photoUrl);
      
      // Met √† jour le profil utilisateur avec l'URL
      await this.userService.put(userId, { photo: photoUrl });
      console.log('üì§ Profil utilisateur mis √† jour');
      
      console.log(`üì∏ Nouvelle photo upload√©e avec succ√®s: ${photoUrl}`);
      return { 
        success: true,
        photo: photoUrl,
        message: 'Photo upload√©e avec succ√®s'
      };
    } catch (error) {
      console.error('‚ùå Erreur d√©taill√©e lors de l\'upload de photo:', {
        message: error.message,
        stack: error.stack,
        name: error.name
      });
      throw error;
    }
  }

  @UseGuards(JwtAuthGuard)
  @Delete('profile/photo')
  async deletePhoto(@Req() req) {
    try {
      // R√©cup√©rer l'utilisateur actuel
      const currentUser = await this.userService.findOne(req.user.userId);
      
      // Supprimer la photo si elle existe et n'est pas la photo par d√©faut
      if (currentUser.photo && currentUser.photo !== '/api/files/profiles/default.jpg') {
        const oldPhotoPath = currentUser.photo.replace('/api/files/profiles/', './uploads/profiles/');
        const fs = require('fs');
        if (fs.existsSync(oldPhotoPath)) {
          fs.unlinkSync(oldPhotoPath);
          console.log(`üóëÔ∏è Photo supprim√©e: ${oldPhotoPath}`);
        }
      }

      // Remettre la photo par d√©faut
      await this.userService.put(req.user.userId, { photo: '/api/files/profiles/default.jpg' });
      
      console.log(`üì∏ Photo supprim√©e, photo par d√©faut restaur√©e`);
      return { message: 'Photo supprim√©e avec succ√®s' };
    } catch (error) {
      console.error('‚ùå Erreur lors de la suppression de photo:', error);
      throw error;
    }
  }

  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(UserRole.ADMIN)
  @Post('fix-missing-photos')
  async fixMissingPhotos() {
    return await this.userService.fixMissingPhotos();
  }
}
